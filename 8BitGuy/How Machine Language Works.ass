[Script Info]
; Script generated by Aegisub 3.2.2
; http://www.aegisub.org/
Title: Default Aegisub file
ScriptType: v4.00+
WrapStyle: 0
ScaledBorderAndShadow: yes
YCbCr Matrix: TV.601
PlayResX: 1920
PlayResY: 1080

[Aegisub Project Garbage]
Audio File: How Machine Language Works-HWpi9n2H3kE.mkv
Video File: How Machine Language Works-HWpi9n2H3kE.mkv
Video AR Mode: 4
Video AR Value: 1.777778
Video Zoom Percent: 0.375000
Scroll Position: 316
Active Line: 310
Video Position: 35010

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1
Style: Comments,文泉驿等宽微米黑,56,&H0000FFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,8,10,10,35,1
Style: Chinese,文泉驿等宽微米黑,80,&H00FFFFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,94,1
Style: English,Comic Sans MS,60,&H0000FFFF,&H000000FF,&H00000000,&H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,30,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:11.29,0:00:12.57,Chinese,,0,0,0,,主持人：请问这些数字和字母都是什么意思？
Dialogue: 0,0:00:12.57,0:00:16.35,Chinese,,0,0,0,,爷爷：这应该是早期版本的程序，这些指令应该是机器代码吧
Dialogue: 0,0:00:16.35,0:00:17.96,Chinese,,0,0,0,,孙子：这个真没意思  爷爷：怎么会呢？
Dialogue: 0,0:00:11.29,0:00:17.96,Comments,,0,0,0,,SuperBart：以下片段应该来自Doctor Who，我没看过，所以人物都是瞎写的
Dialogue: 0,0:00:19.00,0:00:22.99,Chinese,,0,0,0,,80年代的时候，我还很小，手边有VIC-20和C64
Dialogue: 0,0:00:22.99,0:00:26.14,Chinese,,0,0,0,,那时我通过输入BASIC程序来学习编程
Dialogue: 0,0:00:26.22,0:00:28.68,Chinese,,0,0,0,,进而我能熟练地编写BASIC程序了
Dialogue: 0,0:00:28.68,0:00:30.75,Chinese,,0,0,0,,那些程序大多在编程书和杂志上
Dialogue: 0,0:00:30.75,0:00:33.60,Chinese,,0,0,0,,但当我搞到一份商业软件的时候
Dialogue: 0,0:00:33.60,0:00:37.05,Chinese,,0,0,0,,我尝试列出程序源代码，可我只能看到
Dialogue: 0,0:00:37.05,0:00:39.60,Chinese,,0,0,0,,一行代码，上面只有SYS命令和一串数字
Dialogue: 0,0:00:39.60,0:00:45.29,Chinese,,0,0,0,,我对其中原理一无所知，觉得这就是魔法:-P
Dialogue: 0,0:00:45.29,0:00:50.60,Chinese,,0,0,0,,后来，我才知道这些程序是用机器语言编写的，简称ML
Dialogue: 0,0:00:50.60,0:00:54.68,Chinese,,0,0,0,,不光Commodore是这样，实际上，在大多数八位机上
Dialogue: 0,0:00:54.68,0:00:59.04,Chinese,,0,0,0,,百分之99的商业软件和游戏都是用机器语言写的
Dialogue: 0,0:00:59.04,0:01:04.04,Chinese,,0,0,0,,这其中包括你喜欢的雅达利2600游戏，红白机游戏
Dialogue: 0,0:01:04.04,0:01:06.24,Chinese,,0,0,0,,Apple II系列电脑上的游戏，当然还有很多
Dialogue: 0,0:01:06.62,0:01:10.75,Chinese,,0,0,0,,所以说，机器语言程序在当时是十分常见的，而不是个例
Dialogue: 0,0:01:10.75,0:01:15.10,Chinese,,0,0,0,,本期视频，我想让大家稍微了解一下机器语言是啥
Dialogue: 0,0:01:15.10,0:01:17.16,Chinese,,0,0,0,,当然，我不会教你如何用机器语言编程
Dialogue: 0,0:01:17.16,0:01:20.96,Chinese,,0,0,0,,因为这大概十个小时都教不完，而且十分枯燥:-(
Dialogue: 0,0:01:20.96,0:01:24.03,Chinese,,0,0,0,,但我还是希望大家能明白机器语言与
Dialogue: 0,0:01:24.03,0:01:26.11,Chinese,,0,0,0,,其他编程语言相比，有什么特点
Dialogue: 0,0:01:26.11,0:01:30.32,Chinese,,0,0,0,,在我讲机器语言是啥之前，我想告诉大家它不是什么
Dialogue: 0,0:01:30.97,0:01:34.60,Chinese,,0,0,0,,我先从这个BASIC写的示例程序来说
Dialogue: 0,0:01:34.60,0:01:39.50,Chinese,,0,0,0,,上一集我用它来测试，我觉得在这也一样
Dialogue: 0,0:01:39.50,0:01:44.49,Chinese,,0,0,0,,这个BASIC程序我尽力优化，以让其在1Mhz的电脑上运行
Dialogue: 0,0:01:44.49,0:01:49.36,Chinese,,0,0,0,,那时我们有一个为C64开发的程序，叫Blitz! Basic
Dialogue: 0,0:01:44.49,0:01:49.36,Comments,,0,0,0,,注：程序翻译为 加速Basic程序
Dialogue: 0,0:01:49.36,0:01:51.96,Chinese,,0,0,0,,应该也被叫做Austrospeed
Dialogue: 0,0:01:51.96,0:01:58.60,Chinese,,0,0,0,,在那时，我们对其能将BASIC编译为机器语言印象深刻
Dialogue: 0,0:01:58.60,0:02:02.94,Chinese,,0,0,0,,但实际上这不完全正确，别误会我，软件从来没有这么说过
Dialogue: 0,0:02:02.94,0:02:06.06,Chinese,,0,0,0,,实际上它将源代码转换为了P-Code
Dialogue: 0,0:02:06.06,0:02:08.56,Chinese,,0,0,0,,实际上，P-Code也是一种解释型语言
Dialogue: 0,0:02:08.56,0:02:12.06,Chinese,,0,0,0,,只不过专门为运行速度而优化
Dialogue: 0,0:02:12.06,0:02:16.02,Chinese,,0,0,0,,如果你在编译程序后查看源代码，你只会看到Blitz!
Dialogue: 0,0:02:16.02,0:02:18.92,Chinese,,0,0,0,,如图所示，显然源代码不能像BASIC一样可编辑
Dialogue: 0,0:02:18.92,0:02:22.63,Chinese,,0,0,0,,估计这也是为什么大家普遍认为它是机器语言
Dialogue: 0,0:02:22.63,0:02:31.40,Chinese,,0,0,0,,如你所见，与原版BASIC程序相比，Blitz!优化版要更快
Dialogue: 0,0:02:31.40,0:02:35.31,Chinese,,0,0,0,,尽管还是赶不上机器语言的翻译速度，用Blitz!优化后
Dialogue: 0,0:02:35.31,0:02:41.14,Chinese,,0,0,0,,基本上运行速度都要快2到8倍，看你用的是什么指令了
Dialogue: 0,0:02:41.14,0:02:43.97,Chinese,,0,0,0,,所以，原理是什么呢？我给大家
Dialogue: 0,0:02:43.97,0:02:48.62,Chinese,,0,0,0,,举个例子，看一下这个示例程序，再看看Blitz!是怎么优化的
Dialogue: 0,0:02:48.62,0:02:51.02,Chinese,,0,0,0,,首先，所有REM声明可以被省略
Dialogue: 0,0:02:51.02,0:02:53.42,Chinese,,0,0,0,,反正这是用来注释代码的
Dialogue: 0,0:02:53.42,0:02:56.74,Chinese,,0,0,0,,但是它占地儿啊，而且会略微减缓程序运行
Dialogue: 0,0:02:56.74,0:02:59.91,Chinese,,0,0,0,,既然代码已经无法编辑了，还不如删了呢:-)
Dialogue: 0,0:03:00.58,0:03:03.59,Chinese,,0,0,0,,接下来，我们要看一下BASIC程序中各行代码
Dialogue: 0,0:03:03.59,0:03:07.60,Chinese,,0,0,0,,在内存中的储存位置，并标出实际的内存地址
Dialogue: 0,0:03:08.00,0:03:13.60,Chinese,,0,0,0,,然后我们看有行数的代码，像GOTO，GOSUB，还有NEXT
Dialogue: 0,0:03:13.60,0:03:16.44,Chinese,,0,0,0,,然后搞明白它指向的内存地址
Dialogue: 0,0:03:16.44,0:03:18.57,Chinese,,0,0,0,,一般来说，这些工作是在程序运行过程中执行的
Dialogue: 0,0:03:18.57,0:03:21.49,Chinese,,0,0,0,,而寻找代码行号，进而定位内存地址是相当耗费时间的
Dialogue: 0,0:03:21.80,0:03:26.21,Chinese,,0,0,0,,所以，为加快运行速度，你可以将行号换成对应的内存地址
Dialogue: 0,0:03:26.21,0:03:28.65,Chinese,,0,0,0,,那么，程序执行时就不需要找行号了
Dialogue: 0,0:03:28.65,0:03:33.22,Chinese,,0,0,0,,当然，行号也不需要了，所以删掉他们就行了B-)
Dialogue: 0,0:03:33.73,0:03:38.41,Chinese,,0,0,0,,目前这里还有一些数可以优化，在BASIC代码里的这些数
Dialogue: 0,0:03:38.41,0:03:41.94,Chinese,,0,0,0,,实际上是纯字符，也可叫做字符串
Dialogue: 0,0:03:41.94,0:03:46.65,Chinese,,0,0,0,,那么，像53280这样的数，实际上分别存于五个独立的字节中
Dialogue: 0,0:03:46.65,0:03:50.08,Chinese,,0,0,0,,你可以用机器语言监视器打开程序，然后看到这种现象
Dialogue: 0,0:03:50.57,0:03:55.25,Chinese,,0,0,0,,问题是，在程序执行过程中，数字字符必须转换成数字
Dialogue: 0,0:03:55.25,0:04:00.88,Chinese,,0,0,0,,所以说，我们完全可以提前转换完，以节省程序运行时间
Dialogue: 0,0:04:01.16,0:04:06.44,Chinese,,0,0,0,,以上就是诸如Blitz这样的优化程序加速BASIC程序的方法了
Dialogue: 0,0:04:06.44,0:04:08.84,Chinese,,0,0,0,,但它们本质上还是BASIC程序
Dialogue: 0,0:04:08.84,0:04:13.24,Chinese,,0,0,0,,它们依旧需要解释运行，根本不是机器语言
Dialogue: 0,0:04:13.24,0:04:15.70,Chinese,,0,0,0,,但这本身并不是什么问题
Dialogue: 0,0:04:15.70,0:04:20.82,Chinese,,0,0,0,,如果你是BASIC高手，这也是提升运行速度的方法之一
Dialogue: 0,0:04:20.82,0:04:23.45,Chinese,,0,0,0,,那么，到底什么是机器语言呢？
Dialogue: 0,0:04:23.45,0:04:26.27,Chinese,,0,0,0,,这是种与处理器本身十分相关的语言
Dialogue: 0,0:04:26.27,0:04:28.36,Chinese,,0,0,0,,处理器只会认识机器语言
Dialogue: 0,0:04:28.36,0:04:32.54,Chinese,,0,0,0,,你在电脑上运行的每一个程序，无论是在古董电脑上的
Dialogue: 0,0:04:32.54,0:04:35.34,Chinese,,0,0,0,,还是在现代电脑上的，都是机器语言程序
Dialogue: 0,0:04:35.34,0:04:37.58,Chinese,,0,0,0,,要不然，电脑CPU不知道如何执行它
Dialogue: 0,0:04:37.58,0:04:43.17,Chinese,,0,0,0,,也就是说，你用其他语言编程，它们终会变成机器语言
Dialogue: 0,0:04:43.17,0:04:44.98,Chinese,,0,0,0,,而这有两种方法实现
Dialogue: 0,0:04:45.49,0:04:48.88,Chinese,,0,0,0,,诸如 BASIC Java Python Ruby Perl 这样的语言
Dialogue: 0,0:04:48.88,0:04:53.86,Chinese,,0,0,0,,都是解释型语言，他们运行时都需要解释器
Dialogue: 0,0:04:53.86,0:04:58.38,Chinese,,0,0,0,,亦可称运行时环境，它们运行时一行行读取代码
Dialogue: 0,0:04:58.38,0:05:02.17,Chinese,,0,0,0,,然后转换成CPU能执行的机器代码指令
Dialogue: 0,0:05:02.17,0:05:05.37,Chinese,,0,0,0,,解释器必须与程序同时工作
Dialogue: 0,0:05:05.37,0:05:09.74,Chinese,,0,0,0,,在性能方面，解释型语言是比较慢的一类
Dialogue: 0,0:05:09.74,0:05:12.22,Chinese,,0,0,0,,但是它们的学习曲线更平缓
Dialogue: 0,0:05:12.80,0:05:17.82,Chinese,,0,0,0,,另一方面，诸如 C++, Pascal, C#, Cobol 和汇编语言
Dialogue: 0,0:05:17.82,0:05:22.97,Chinese,,0,0,0,,需要编译器编译，也就将代码永久翻译为机器语言
Dialogue: 0,0:05:17.82,0:05:22.97,Comments,,0,0,0,,注：即编译型语言
Dialogue: 0,0:05:22.97,0:05:27.54,Chinese,,0,0,0,,只要编译完了，你不需要编译器就能运行程序了
Dialogue: 0,0:05:27.54,0:05:30.68,Chinese,,0,0,0,,当然，如果你需要更改程序的话，你还得用编译器:-(
Dialogue: 0,0:05:30.68,0:05:34.68,Chinese,,0,0,0,,在性能方面，编译型语言较解释型语言更佳
Dialogue: 0,0:05:34.68,0:05:37.34,Chinese,,0,0,0,,但我之前说过，这个的学习曲线较为陡峭
Dialogue: 0,0:05:37.83,0:05:40.25,Chinese,,0,0,0,,那个，你们先不要去评论区说
Dialogue: 0,0:05:40.25,0:05:42.71,Chinese,,0,0,0,,我把Java和C#给分类错了
Dialogue: 0,0:05:43.34,0:05:45.91,Chinese,,0,0,0,,我这个分类是一个相当笼统的分类
Dialogue: 0,0:05:45.91,0:05:48.80,Chinese,,0,0,0,,我也知道编程语言类型不是非此即彼的
Dialogue: 0,0:05:48.80,0:05:53.11,Chinese,,0,0,0,,主要在于，它们在运行中总归要变成机器语言
Dialogue: 0,0:05:53.37,0:05:55.78,Chinese,,0,0,0,,那么，机器语言长什么样呢？
Dialogue: 0,0:05:55.78,0:05:57.88,Chinese,,0,0,0,,基本上，它们就是堆数字
Dialogue: 0,0:05:57.88,0:06:02.35,Chinese,,0,0,0,,这个示例小程序能使C128显示边框闪烁
Dialogue: 0,0:06:02.35,0:06:06.91,Chinese,,0,0,0,,第一个数字是CPU命令，亦称“指令”，俗称Op-Code
Dialogue: 0,0:06:06.91,0:06:10.60,Chinese,,0,0,0,,这个指令可以将相应内存内容增1
Dialogue: 0,0:06:06.91,0:06:10.60,Comments,,0,0,0,,注：EE=INC $addr16 EAC=A存储器单元内容增1
Dialogue: 0,0:06:10.60,0:06:14.31,Chinese,,0,0,0,,接下来两个数是需要增1的内存地址
Dialogue: 0,0:06:14.31,0:06:17.91,Chinese,,0,0,0,,这个数字又是一个指令，是让CPU无条件跳转的
Dialogue: 0,0:06:17.91,0:06:20.91,Chinese,,0,0,0,,或是跳转到另一块需要继续执行的内存
Dialogue: 0,0:06:20.91,0:06:25.91,Chinese,,0,0,0,,当然，指令接下来的两个数是需要跳转到的内存地址
Dialogue: 0,0:06:25.91,0:06:29.05,Chinese,,0,0,0,,很早期的电脑实际上就是这么编程的
Dialogue: 0,0:06:29.05,0:06:31.55,Chinese,,0,0,0,,像Altair，前面板就是编程用开关
Dialogue: 0,0:06:31.55,0:06:33.71,Chinese,,0,0,0,,或是KIM-1这样的老电脑
Dialogue: 0,0:06:34.08,0:06:36.91,Chinese,,0,0,0,,如果你还是很疑惑，不停地想：
Dialogue: 0,0:06:36.91,0:06:40.68,Chinese,,0,0,0,,“还有谁会用机器语言编写复杂的程序呢？”
Dialogue: 0,0:06:40.68,0:06:45.31,Chinese,,0,0,0,,实际上，没人会，至少70年代之后就没有了
Dialogue: 0,0:06:45.31,0:06:47.85,Chinese,,0,0,0,,我现在给大家举个例子，当然不是吓唬你们啦
Dialogue: 0,0:06:47.85,0:06:53.28,Chinese,,0,0,0,,只是让大家明白机器语言和汇编语言的区别
Dialogue: 0,0:06:53.28,0:06:58.61,Chinese,,0,0,0,,平常我们都用，虽然它们之间关系紧密，但毕竟不是一个东西
Dialogue: 0,0:06:58.97,0:07:02.51,Chinese,,0,0,0,,这有点像音乐和乐谱间的区别
Dialogue: 0,0:07:02.51,0:07:05.60,Chinese,,0,0,0,,这俩之间有十分直接的关系，你听到的音符
Dialogue: 0,0:07:05.60,0:07:10.17,Chinese,,0,0,0,,和乐谱上的音符能一一对应，但他们依然不是同一种东西
Dialogue: 0,0:07:10.17,0:07:14.60,Chinese,,0,0,0,,既然我说不明白，我还是给大家演示一下吧
Dialogue: 0,0:07:14.60,0:07:19.20,Chinese,,0,0,0,,首先，我先用BASIC写一个能刷新显示边框的小程序
Dialogue: 0,0:07:19.20,0:07:21.45,Chinese,,0,0,0,,我觉得这个小程序可以说明一些问题
Dialogue: 0,0:07:21.45,0:07:25.62,Chinese,,0,0,0,,它只是向显示边框寄存器依次写入0到225
Dialogue: 0,0:07:25.62,0:07:28.40,Chinese,,0,0,0,,然后不停重复以上步骤
Dialogue: 0,0:07:28.40,0:07:33.77,Chinese,,0,0,0,,看上去程序执行得很快，边框更新速度快于屏幕显示速度
Dialogue: 0,0:07:33.77,0:07:36.82,Chinese,,0,0,0,,这也是为什么边框出现了不止一个颜色
Dialogue: 0,0:07:36.82,0:07:39.27,Chinese,,0,0,0,,所以说，这就很快了吗？
Dialogue: 0,0:07:39.27,0:07:43.85,Chinese,,0,0,0,,现在，我们用内置的机器语言监视器，用汇编语言重写程序
Dialogue: 0,0:07:43.85,0:07:47.77,Chinese,,0,0,0,,我们先找到程序开始的内存地址，即十六进制的1300
Dialogue: 0,0:07:47.77,0:07:50.37,Chinese,,0,0,0,,我们现在需要往显示寄存器中增1
Dialogue: 0,0:07:50.37,0:07:55.50,Chinese,,0,0,0,,这里的D020和BASIC里的53280是同一个数字
Dialogue: 0,0:07:55.50,0:07:58.30,Chinese,,0,0,0,,只不过一个是十六进制，一个是二进制
Dialogue: 0,0:07:58.30,0:08:03.18,Chinese,,0,0,0,,现在看这三个数字，这是存储在内存中的机器语言数字代码
Dialogue: 0,0:08:03.18,0:08:07.38,Chinese,,0,0,0,,右边的部分我们人类可以理解，我们称作汇编
Dialogue: 0,0:08:07.38,0:08:12.08,Chinese,,0,0,0,,这个机器语言命令是JMP，有点像BASIC里的GOTO
Dialogue: 0,0:08:12.08,0:08:16.30,Chinese,,0,0,0,,我们要跳回内存地址1300，也就是跳回开始，无限循环
Dialogue: 0,0:08:16.30,0:08:20.22,Chinese,,0,0,0,,也就是说，这个程序比BASIC版的更小，更简单
Dialogue: 0,0:08:20.84,0:08:25.40,Chinese,,0,0,0,,那么，我们退出监视器，回到BASIC环境，输入SYS启动程序
Dialogue: 0,0:08:25.40,0:08:27.78,Chinese,,0,0,0,,SYS在Commodore BASIC中指机器语言程序
Dialogue: 0,0:08:27.78,0:08:32.50,Chinese,,0,0,0,,地址是十进制的4864，即十六进制的1300
Dialogue: 0,0:08:32.50,0:08:36.46,Chinese,,0,0,0,,好的，启动了。程序运行过快，显示单元每次只能
Dialogue: 0,0:08:36.46,0:08:40.89,Chinese,,0,0,0,,更新几个像素，看上去就更奇怪了
Dialogue: 0,0:08:40.90,0:08:45.14,Chinese,,0,0,0,,现在，我要给大家写一个更简单的程序，先是BASIC版的
Dialogue: 0,0:08:45.14,0:08:51.60,Chinese,,0,0,0,,这个程序是将所有的225个字符全部显示出来
Dialogue: 0,0:08:51.88,0:08:54.44,Chinese,,0,0,0,,显示内存地址从1024开始
Dialogue: 0,0:08:55.32,0:08:58.50,Chinese,,0,0,0,,这样就行了，看看执行时长
Dialogue: 0,0:08:59.20,0:09:02.72,Chinese,,0,0,0,,好的，大概三到四秒，这应该还行吧
Dialogue: 0,0:09:03.64,0:09:06.26,Chinese,,0,0,0,,现在我用机器语言监视器写机器语言版
Dialogue: 0,0:09:06.26,0:09:09.04,Chinese,,0,0,0,,程序就几行，我就写给大家看了
Dialogue: 0,0:09:09.04,0:09:11.88,Chinese,,0,0,0,,没都理解不要紧，大概能懂就行
Dialogue: 0,0:09:12.22,0:09:18.08,Chinese,,0,0,0,,LDX命令能将寄存器X清零，即将X寄存器里的数值全部变成0
Dialogue: 0,0:09:18.08,0:09:21.40,Chinese,,0,0,0,,TXA命令是将X寄存器的内容送入累加器
Dialogue: 0,0:09:21.40,0:09:25.30,Chinese,,0,0,0,,STA命令能将累加器内的内容变成400
Dialogue: 0,0:09:25.30,0:09:27.82,Chinese,,0,0,0,,也就是显示内存地址1024的十六进制表示
Dialogue: 0,0:09:27.82,0:09:33.14,Chinese,,0,0,0,,后面的',X'意思是在存储前累加寄存器X
Dialogue: 0,0:09:33.14,0:09:35.74,Chinese,,0,0,0,,INX命令能让寄存器X自增1
Dialogue: 0,0:09:35.74,0:09:37.62,Chinese,,0,0,0,,然后我们要将寄存器X与0进行比较
Dialogue: 0,0:09:37.62,0:09:40.54,Chinese,,0,0,0,,与零进行比较的原因是，这是台八位电脑
Dialogue: 0,0:09:40.54,0:09:45.10,Chinese,,0,0,0,,如果目前数值是225的话，再自增1的话，寄存器会归零
Dialogue: 0,0:09:45.16,0:09:50.36,Chinese,,0,0,0,,比较后，如果不等于的话，CPU会继续运行
Dialogue: 0,0:09:50.36,0:09:53.82,Chinese,,0,0,0,,要是等于的话，就运行RTS命令，回到BASIC环境
Dialogue: 0,0:09:54.68,0:09:57.66,Chinese,,0,0,0,,好的，简单解释完了，现在执行
Dialogue: 0,0:09:57.94,0:10:03.73,Chinese,,0,0,0,,运行得真快，我手指还没离开回车键就完事了
Dialogue: 0,0:10:04.02,0:10:06.00,Chinese,,0,0,0,,我现在再运行一遍
Dialogue: 0,0:10:06.52,0:10:10.66,Chinese,,0,0,0,,现在你看到了汇编语言长啥样了，以下是《终结者》选段
Dialogue: 0,0:10:10.66,0:10:14.08,Chinese,,0,0,0,,这里显示的就是汇编语言，更准确说
Dialogue: 0,0:10:14.08,0:10:19.46,Chinese,,0,0,0,,Apple II电脑上的6502机器语言，现在没几个人认得了
Dialogue: 0,0:10:20.24,0:10:23.44,Chinese,,0,0,0,,{\pos(965.333,155.333)}所以说，为啥汇编版程序比BASIC版运行更快？
Dialogue: 0,0:10:23.44,0:10:25.71,Chinese,,0,0,0,,{\pos(965.333,155.333)}我之前说过，BASIC是解释型语言
Dialogue: 0,0:10:25.71,0:10:31.82,Chinese,,0,0,0,,{\pos(965.333,155.333)}每一条BASIC指令都要解释为好几百行机器语言指令
Dialogue: 0,0:10:31.82,0:10:37.10,Chinese,,0,0,0,,{\pos(965.333,155.333)}因而，机器语言版程序都要比任何BASIC程序快至少好几百倍
Dialogue: 0,0:10:37.10,0:10:41.92,Chinese,,0,0,0,,现在我得说明一下，机器语言不止一种
Dialogue: 0,0:10:41.92,0:10:44.94,Chinese,,0,0,0,,如果用C语言，或是Python语言写程序的话，你可以
Dialogue: 0,0:10:44.94,0:10:48.06,Chinese,,0,0,0,,在不同架构CPU的电脑上运行它
Dialogue: 0,0:10:48.06,0:10:52.38,Chinese,,0,0,0,,但机器语言编程十分依赖你电脑上的CPU
Dialogue: 0,0:10:52.38,0:10:56.14,Chinese,,0,0,0,,比如说，在6502上写的汇编程序无法在Z80上运行
Dialogue: 0,0:10:56.14,0:10:58.14,Chinese,,0,0,0,,这两个CPU的机器语言不相同
Dialogue: 0,0:10:58.14,0:11:03.69,Chinese,,0,0,0,,但这期视频，我还是用6502机器语言举例，因为这个还算简单
Dialogue: 0,0:11:03.69,0:11:09.72,Chinese,,0,0,0,,6502 CPU有151个CPU指令，但大多数在实践中用不到
Dialogue: 0,0:11:09.72,0:11:12.90,Chinese,,0,0,0,,实际上，记下56个指令就够用了
Dialogue: 0,0:11:12.90,0:11:17.22,Chinese,,0,0,0,,比如说，如果你要将数值加载至寄存器，你可以用LDA指令
Dialogue: 0,0:11:17.22,0:11:20.58,Chinese,,0,0,0,,你可以直接加载一个数，诸如42
Dialogue: 0,0:11:20.58,0:11:23.96,Chinese,,0,0,0,,或者你可以像这样，加载一个内存地址
Dialogue: 0,0:11:23.96,0:11:28.42,Chinese,,0,0,0,,你再看左边，里面的CPU指令是不同的
Dialogue: 0,0:11:28.42,0:11:31.04,Chinese,,0,0,0,,但是我们没必要搞明白这些东西
Dialogue: 0,0:11:31.04,0:11:34.39,Chinese,,0,0,0,,汇编器能够找到对应的CPU指令
Dialogue: 0,0:11:34.39,0:11:37.52,Chinese,,0,0,0,,目前，我都是在机器语言监视器中编写程序
Dialogue: 0,0:11:37.52,0:11:39.92,Chinese,,0,0,0,,它可以查看并修改机器语言指令
Dialogue: 0,0:11:39.92,0:11:44.46,Chinese,,0,0,0,,但你肯定不想在这里写一些很多很多行的程序
Dialogue: 0,0:11:44.46,0:11:48.50,Chinese,,0,0,0,,因为你要为写很多子程序而记忆很多内存地址
Dialogue: 0,0:11:48.50,0:11:54.83,Chinese,,0,0,0,,而且基本不能插入代码，你只能将代码给覆盖了
Dialogue: 0,0:11:54.83,0:11:57.50,Chinese,,0,0,0,,相比之下，汇编器就很好用了
Dialogue: 0,0:11:57.50,0:12:00.86,Chinese,,0,0,0,,以下是我最近编写的游戏的代码片段
Dialogue: 0,0:12:00.86,0:12:03.20,Chinese,,0,0,0,,如你所见，这些代码都是用文本编辑器写的
Dialogue: 0,0:12:03.20,0:12:06.54,Chinese,,0,0,0,,看上去更好用了，每个子程序都有好理解的内存地址名
Dialogue: 0,0:12:06.54,0:12:09.36,Chinese,,0,0,0,,诸如 Search Object 和 Display Player Sprite
Dialogue: 0,0:12:06.54,0:12:09.36,Comments,,0,0,0,,{\pos(533,845)}寻找对象
Dialogue: 0,0:12:06.54,0:12:09.36,Comments,,0,0,0,,{\pos(1400,845)}显示玩家图像
Dialogue: 0,0:12:09.36,0:12:14.10,Chinese,,0,0,0,,所以汇编器更好用嘛，那汇编器是怎么工作的呢？
Dialogue: 0,0:12:14.64,0:12:17.28,Chinese,,0,0,0,,这里我拿记事本写了一个小程序
Dialogue: 0,0:12:17.28,0:12:22.08,Chinese,,0,0,0,,在编译后，我将用机器语言监视器看看编译后成了啥样
Dialogue: 0,0:12:22.08,0:12:26.62,Chinese,,0,0,0,,首先，汇编中所有的指令都被照搬了
Dialogue: 0,0:12:26.62,0:12:28.92,Chinese,,0,0,0,,机器语言和汇编在这方面没有任何区别
Dialogue: 0,0:12:28.92,0:12:34.06,Chinese,,0,0,0,,但是，内存地址名都变成了内存地址，比如‘screen RAM’
Dialogue: 0,0:12:28.92,0:12:34.06,Comments,,0,0,0,,{\pos(1600,845)}屏幕显示内存
Dialogue: 0,0:12:34.06,0:12:38.60,Chinese,,0,0,0,,还有，我用来循环用的命令也编译成相应内存地址了
Dialogue: 0,0:12:38.60,0:12:42.60,Chinese,,0,0,0,,这个地址正好就是我标注的循环开始地址
Dialogue: 0,0:12:42.60,0:12:45.68,Chinese,,0,0,0,,当然，如果你想直接看机器代码本身的话
Dialogue: 0,0:12:45.68,0:12:47.08,Chinese,,0,0,0,,你也可以直接看这个
Dialogue: 0,0:12:47.58,0:12:55.20,Chinese,,0,0,0,,希望我刚才能说明白机器语言和汇编语言的区别
Dialogue: 0,0:12:55.20,0:12:58.30,Chinese,,0,0,0,,它们就是一个东西的两个面目罢了
Dialogue: 0,0:12:58.30,0:13:02.08,Chinese,,0,0,0,,在以前，有些程序员确实需要用机器语言编程
Dialogue: 0,0:13:02.08,0:13:06.68,Chinese,,0,0,0,,大量使用汇编器，使代码更加可读
Dialogue: 0,0:13:07.16,0:13:12.54,Chinese,,0,0,0,,那么，你可能会有疑问了，为什么汇编用的数字都是十六进制？
Dialogue: 0,0:13:12.54,0:13:15.82,Chinese,,0,0,0,,在此，我要解释一下十六进制是啥
Dialogue: 0,0:13:15.82,0:13:18.70,Chinese,,0,0,0,,十六进制是十六进一，而不是十进一
Dialogue: 0,0:13:18.70,0:13:22.12,Chinese,,0,0,0,,另外还多了A,B,C,D,E.F六个字符
Dialogue: 0,0:13:22.12,0:13:25.72,Chinese,,0,0,0,,为什么用它很方便呢？因为我们处理二进制数字时
Dialogue: 0,0:13:25.72,0:13:31.07,Chinese,,0,0,0,,一个十六进制数可以表示四个比特，行话叫nybble
Dialogue: 0,0:13:25.72,0:13:31.07,Comments,,0,0,0,,{\pos(1600,845)}半字节
Dialogue: 0,0:13:31.07,0:13:35.90,Chinese,,0,0,0,,因此，十六进制的9A就比十进制的154好记多了
Dialogue: 0,0:13:36.52,0:13:41.62,Chinese,,0,0,0,,还有一个好处是在写汇编语言时，频繁查看内存地址
Dialogue: 0,0:13:41.62,0:13:47.70,Chinese,,0,0,0,,对于CPU来说，64K的内存寻址是在十进制的0到65535之间
Dialogue: 0,0:13:47.70,0:13:50.90,Chinese,,0,0,0,,但是，用十六进制表示的话，是0到FFFF
Dialogue: 0,0:13:50.90,0:13:55.45,Chinese,,0,0,0,,而这在用比特形式看内存地址时，就十分管用了
Dialogue: 0,0:13:50.90,0:13:55.45,Comments,,0,0,0,,注：一个比特等于八位二进制数字
Dialogue: 0,0:13:55.45,0:13:58.05,Chinese,,0,0,0,,这是同一个内存地址，分别用十六进制和十进制表示
Dialogue: 0,0:13:58.05,0:14:01.32,Chinese,,0,0,0,,这个地址是C64中表示显示边框颜色的地址
Dialogue: 0,0:14:01.32,0:14:04.00,Chinese,,0,0,0,,你可以用POKE命令来更改边框颜色
Dialogue: 0,0:14:04.00,0:14:08.40,Chinese,,0,0,0,,在汇编中，这个地址正好用两个比特表示
Dialogue: 0,0:14:08.40,0:14:13.92,Chinese,,0,0,0,,用十六进制表示的话，正好是D0和20，挺好理解
Dialogue: 0,0:14:10.38,0:14:15.78,Comments,,0,0,0,,{\pos(578.667,775.666)}1101 0000
Dialogue: 0,0:14:10.38,0:14:15.78,Comments,,0,0,0,,{\pos(861.333,775.666)}0010 0000
Dialogue: 0,0:14:13.92,0:14:20.72,Chinese,,0,0,0,,但用十进制的话，这两个比特就成了208和32，完全理解不能
Dialogue: 0,0:14:20.72,0:14:23.42,Chinese,,0,0,0,,实际上，这么写是正确的，不过得算一下
Dialogue: 0,0:14:23.42,0:14:31.82,Chinese,,0,0,0,,你先算208*256=53248，然后将低位的32加上，得到53280
Dialogue: 0,0:14:23.42,0:14:31.82,Comments,,0,0,0,,注：十六进制中，“个位”代表1，“十位”代表16，“百位”代表16*16=256
Dialogue: 0,0:14:31.82,0:14:36.85,Chinese,,0,0,0,,如你所见，程序员处理十六进制的话，会更加顺手
Dialogue: 0,0:14:37.50,0:14:39.97,Chinese,,0,0,0,,看看，连他们都在 Logopolis 上使用二进制
Dialogue: 0,0:14:39.97,0:14:42.89,Chinese,,0,0,0,,所以十六进制真是电脑之友啊:-)
Dialogue: 0,0:14:45.12,0:14:50.22,Chinese,,0,0,0,,孙子:......23，等会，您刚才是说E9吗？这写的是E7！
Dialogue: 0,0:14:51.67,0:14:53.20,Chinese,,0,0,0,,爷爷：你说的没错！
Dialogue: 0,0:14:53.20,0:14:56.53,Chinese,,0,0,0,,关于十六进制，我最后再说一下它应该怎么写
Dialogue: 0,0:14:56.53,0:14:59.80,Chinese,,0,0,0,,在6502汇编语言，PASCAL，Delphi和Forth语言中
Dialogue: 0,0:14:59.80,0:15:05.15,Chinese,,0,0,0,,我们要在十六进制数前加上'$'符号
Dialogue: 0,0:15:05.15,0:15:09.27,Chinese,,0,0,0,,而对于8088汇编，C++，C#，Java，Python等语言来说
Dialogue: 0,0:15:09.27,0:15:15.27,Chinese,,0,0,0,,我们要在十六进制数前加上'0x'符号
Dialogue: 0,0:15:15.27,0:15:20.30,Chinese,,0,0,0,,这些数本质相同，只是编译器识别十六进制的标记不同罢了
Dialogue: 0,0:15:20.30,0:15:23.17,Chinese,,0,0,0,,汇编语言及其相关知识本身是不难的
Dialogue: 0,0:15:23.17,0:15:27.60,Chinese,,0,0,0,,在某些方面，用汇编编程会更简单，比如图形编程
Dialogue: 0,0:15:27.60,0:15:31.57,Chinese,,0,0,0,,但是有利必有弊，某些领域不适合用汇编编程
Dialogue: 0,0:15:31.57,0:15:36.02,Chinese,,0,0,0,,比如字符串相关程序，用汇编编程的话，会很麻烦:-P
Dialogue: 0,0:15:36.02,0:15:40.17,Chinese,,0,0,0,,然而，我认为汇编语言的难点的根源在于
Dialogue: 0,0:15:40.17,0:15:44.65,Chinese,,0,0,0,,你必须了解你所编程的硬件的工作原理
Dialogue: 0,0:15:44.65,0:15:48.17,Chinese,,0,0,0,,假设在 6502 处理器的电脑上，你用汇编语言编程
Dialogue: 0,0:15:48.17,0:15:51.30,Chinese,,0,0,0,,你得用56个汇编命令，本质上，这些命令的作用
Dialogue: 0,0:15:51.30,0:15:54.50,Chinese,,0,0,0,,就是在内存中移动数字
Dialogue: 0,0:15:54.50,0:15:59.16,Chinese,,0,0,0,,那么，像更改画面或是发出音乐这些事，是怎么做到的呢？
Dialogue: 0,0:15:59.16,0:16:04.15,Chinese,,0,0,0,,对于CPU，电脑上每个芯片都被看作是内存之类的东西
Dialogue: 0,0:16:04.15,0:16:07.82,Chinese,,0,0,0,,比如C64上的显示芯片，在内存中就被看作是
Dialogue: 0,0:16:07.82,0:16:12.77,Chinese,,0,0,0,,47个内存地址，从$D000到$D02E
Dialogue: 0,0:16:12.77,0:16:15.52,Chinese,,0,0,0,,既然它不是内存，我们姑且称其为寄存器
Dialogue: 0,0:16:15.52,0:16:18.77,Chinese,,0,0,0,,不过对于CPU来说，这俩东西没什么不同
Dialogue: 0,0:16:18.77,0:16:21.82,Chinese,,0,0,0,,那么，如果我们向显示边框寄存器写入数值的话
Dialogue: 0,0:16:21.82,0:16:24.52,Chinese,,0,0,0,,CPU认为是向某块内存写入数值
Dialogue: 0,0:16:24.52,0:16:28.45,Chinese,,0,0,0,,但实际上，数值被写入显示芯片里的某个寄存器了
Dialogue: 0,0:16:28.45,0:16:31.62,Chinese,,0,0,0,,所以，对于程序员来说，你必须熟悉电脑芯片里的
Dialogue: 0,0:16:31.62,0:16:34.83,Chinese,,0,0,0,,每一个寄存器，及其工作原理
Dialogue: 0,0:16:34.83,0:16:37.72,Chinese,,0,0,0,,当然，如果将某个平台的汇编程序移植到另一个平台
Dialogue: 0,0:16:37.72,0:16:40.10,Chinese,,0,0,0,,诸如将C64的程序移植到Apple II
Dialogue: 0,0:16:40.10,0:16:42.00,Chinese,,0,0,0,,就算这两台电脑用的是一样的CPU
Dialogue: 0,0:16:42.00,0:16:44.00,Chinese,,0,0,0,,其他的东西也完全不同啊
Dialogue: 0,0:16:44.00,0:16:48.63,Chinese,,0,0,0,,这就是移植游戏非常难的原因
Dialogue: 0,0:16:48.63,0:16:54.52,Chinese,,0,0,0,,我觉得这就是为什么我写了两个游戏
Dialogue: 0,0:16:54.52,0:16:58.22,Chinese,,0,0,0,,而不移植到某些人常用平台的
Dialogue: 0,0:16:58.22,0:17:03.52,Chinese,,0,0,0,,就算是两种电脑的CPU相同，移植起来也不容易
Dialogue: 0,0:17:03.52,0:17:06.72,Chinese,,0,0,0,,实际上，确实有一个Apple II的兴趣小组正在将
Dialogue: 0,0:17:06.72,0:17:09.02,Chinese,,0,0,0,,这个游戏移植到Apple II
Dialogue: 0,0:17:09.02,0:17:11.50,Chinese,,0,0,0,,如你所见，大多数功能都实现了
Dialogue: 0,0:17:11.50,0:17:14.95,Chinese,,0,0,0,,当然，Apple II和Commodore电脑用的是同一个CPU
Dialogue: 0,0:17:14.95,0:17:18.90,Chinese,,0,0,0,,所以，这俩版程序里的很多代码可以共用
Dialogue: 0,0:17:18.90,0:17:23.07,Chinese,,0,0,0,,但你还是得重写所有的音频，视频引擎，这个十分麻烦
Dialogue: 0,0:17:23.07,0:17:27.40,Chinese,,0,0,0,,如果有人想让我将游戏移植到使用不同CPU的平台
Dialogue: 0,0:17:27.40,0:17:31.67,Chinese,,0,0,0,,诸如移植到Amiga，ZX Spectrum之类的平台
Dialogue: 0,0:17:31.67,0:17:34.62,Chinese,,0,0,0,,这基本上就是重写程序了
Dialogue: 0,0:17:34.62,0:17:39.27,Chinese,,0,0,0,,所以说，这工作可不容易，如果我花一年来写游戏的话
Dialogue: 0,0:17:39.27,0:17:43.91,Chinese,,0,0,0,,那我就得再花一年来重写这个游戏
Dialogue: 0,0:17:43.91,0:17:47.45,Chinese,,0,0,0,,我觉得现在人们特别喜欢现代语言的原因是
Dialogue: 0,0:17:47.45,0:17:52.15,Chinese,,0,0,0,,如果你用C或是Python编程的话，基本上这个程序
Dialogue: 0,0:17:52.15,0:17:56.82,Chinese,,0,0,0,,可以在多种CPU平台上，或是不同的内存平台上运行
Dialogue: 0,0:17:56.82,0:18:02.62,Chinese,,0,0,0,,基本上编程是单向的，你可以将高级语言编译成机器语言
Dialogue: 0,0:18:02.62,0:18:05.75,Chinese,,0,0,0,,如果你乐意的话，你也可直接用机器语言编程
Dialogue: 0,0:18:05.75,0:18:08.20,Chinese,,0,0,0,,但是反过来就不行了:-(
Dialogue: 0,0:18:08.20,0:18:15.57,Chinese,,0,0,0,,相当于按照乐谱演奏交响曲，但你很难将交响曲变成乐谱
Dialogue: 0,0:18:05.75,0:18:15.57,Comments,,0,0,0,,注：前一种叫反编译，后面说的是扒谱
Dialogue: 0,0:18:15.57,0:18:18.95,Chinese,,0,0,0,,或者说炒鸡蛋，你可以将鸡蛋变成炒鸡蛋
Dialogue: 0,0:18:18.95,0:18:21.54,Chinese,,0,0,0,,但变回去就不可能了
Dialogue: 0,0:18:21.54,0:18:24.85,Chinese,,0,0,0,,如今，汇编编程的艺术很少被人提及
Dialogue: 0,0:18:24.85,0:18:30.50,Chinese,,0,0,0,,编译器可以将高级语言编译成性能很好的机器语言代码
Dialogue: 0,0:18:30.50,0:18:36.72,Chinese,,0,0,0,,现在计算机性能太强了，以至于编译中的性能损失可以忽略了
Dialogue: 0,0:18:36.72,0:18:40.37,Chinese,,0,0,0,,甚至很多操作系统，比如Linux内核，是用C编写的
Dialogue: 0,0:18:40.37,0:18:45.05,Chinese,,0,0,0,,所以说，现在用汇编语言编程并没有什么优势
Dialogue: 0,0:18:45.05,0:18:48.82,Chinese,,0,0,0,,但你要在上世纪七八十年代的电脑上写游戏的话
Dialogue: 0,0:18:48.82,0:18:52.00,Chinese,,0,0,0,,学习机器语言是十分必要的
Dialogue: 0,0:18:52.00,0:18:58.37,Chinese,,0,0,0,,如果你学的话，最后你会懂得很多计算机运行的原理
Dialogue: 0,0:18:58.37,0:19:01.42,Chinese,,0,0,0,,好了，还有一件事，如果你看了我的新工作室
Dialogue: 0,0:19:01.42,0:19:04.47,Chinese,,0,0,0,,觉得这个比以前的要单调的话
Dialogue: 0,0:19:04.85,0:19:07.07,Chinese,,0,0,0,,实际上，这个工作室还没完工
Dialogue: 0,0:19:07.07,0:19:11.85,Chinese,,0,0,0,,但是以前的工作室我给拆了，别的地方也不行
Dialogue: 0,0:19:11.85,0:19:15.32,Chinese,,0,0,0,,所以我只能在这拍了，不过几周内我尽量
Dialogue: 0,0:19:15.32,0:19:17.67,Chinese,,0,0,0,,拍一个新工作室装修视频
Dialogue: 0,0:19:17.67,0:19:23.47,Chinese,,0,0,0,,给大家看看新工作室里面装修完是啥样，希望有所不同
Dialogue: 0,0:19:23.47,0:19:27.00,Chinese,,0,0,0,,希望大家关注哦，最后，感谢大家观看:-)
Dialogue: 0,0:19:27.00,0:19:49.67,Comments,,0,0,0,,时间轴+翻译：SuperBart\N校对:\N原作者The 8-Bit Guy上传于2021-2-14\N注意：本字幕只能由Youtube上The 8-Bit Guy频道的官方授权方发布，其他人不得商用!
Dialogue: 0,0:00:11.29,0:00:12.57,English,,0,0,0,,What do these numbers and letters mean?
Dialogue: 0,0:00:12.57,0:00:16.35,English,,0,0,0,,Well, it’s an early version. The instructions have to be punched in by machine code.
Dialogue: 0,0:00:16.35,0:00:17.96,English,,0,0,0,,Oh how boring. Boring?
Dialogue: 0,0:00:19.00,0:00:22.99,English,,0,0,0,,Back when I was a kid in the 80s with my Commodore VIC-20 and later C64,
Dialogue: 0,0:00:22.99,0:00:26.14,English,,0,0,0,,I had become a whiz at writing code in BASIC,
Dialogue: 0,0:00:26.22,0:00:28.68,English,,0,0,0,,much of which I learned by typing in other BASIC programs
Dialogue: 0,0:00:28.68,0:00:30.75,English,,0,0,0,,from books and magazines.
Dialogue: 0,0:00:30.75,0:00:33.60,English,,0,0,0,,But as I began to acquire more commercial software,
Dialogue: 0,0:00:33.60,0:00:37.05,English,,0,0,0,,when I would attempt “list” the program, all I would see is a single line of
Dialogue: 0,0:00:37.05,0:00:39.60,English,,0,0,0,,BASIC with an SYS command and some numbers.
Dialogue: 0,0:00:39.60,0:00:45.29,English,,0,0,0,,I was mystified at how this worked. It was the equivalent of magic to me.
Dialogue: 0,0:00:45.29,0:00:48.62,English,,0,0,0,,Later on, I was told that these programs were written in machine language,
Dialogue: 0,0:00:48.62,0:00:50.60,English,,0,0,0,,or as we later called ML.
Dialogue: 0,0:00:50.60,0:00:54.68,English,,0,0,0,,This wasn’t just a Commodore thing. in fact, with most 8-bit systems,
Dialogue: 0,0:00:54.68,0:00:59.04,English,,0,0,0,,99% of commercial software and games were written in machine language.
Dialogue: 0,0:00:59.04,0:01:02.30,English,,0,0,0,,This would include your favorite games on the Atari 2600,
Dialogue: 0,0:01:02.30,0:01:06.24,English,,0,0,0,,the Nintendo Entertainment system, Apple II series, and so forth.
Dialogue: 0,0:01:06.62,0:01:10.75,English,,0,0,0,,So, machine language was not the exception, in fact it was the norm.
Dialogue: 0,0:01:10.75,0:01:15.10,English,,0,0,0,,And in this episode, I hope to shed a little bit of light on what machine language actually is.
Dialogue: 0,0:01:15.10,0:01:17.16,English,,0,0,0,,I’m not going to teach you how to code in machine language
Dialogue: 0,0:01:17.16,0:01:20.96,English,,0,0,0,,as that would probably take like 10 hours and be pretty dry and boring.
Dialogue: 0,0:01:20.96,0:01:24.03,English,,0,0,0,,But I do hope to shed a little bit of light on on what machine language actually is
Dialogue: 0,0:01:24.03,0:01:26.11,English,,0,0,0,,as compared to other programming languages.
Dialogue: 0,0:01:26.11,0:01:30.32,English,,0,0,0,,And before I tell you what machine language is, I want to start be telling you what it isn’t.
Dialogue: 0,0:01:30.97,0:01:34.60,English,,0,0,0,,I’ll start by showing you this little demonstration program I wrote in BASIC.
Dialogue: 0,0:01:34.60,0:01:39.50,English,,0,0,0,,I actually used this in a previous episode as a benchmark, and I think it works well here too.
Dialogue: 0,0:01:39.50,0:01:44.49,English,,0,0,0,,This is about as optimized as I can make it running here in BASIC on a 1 Mhz machine.
Dialogue: 0,0:01:44.49,0:01:49.36,English,,0,0,0,,Now, back in the day we had this program for the Commodore 64 called Blitz! Basic.
Dialogue: 0,0:01:49.36,0:01:51.96,English,,0,0,0,,And I think it was also known as Austrospeed.
Dialogue: 0,0:01:51.96,0:01:55.10,English,,0,0,0,,At the time, us common folk were under the impression
Dialogue: 0,0:01:55.10,0:01:58.60,English,,0,0,0,,this would compile your BASIC program into machine language.
Dialogue: 0,0:01:58.60,0:02:02.94,English,,0,0,0,,But, that’s not actually true. Don’t get me wrong, the software never claimed to do this,
Dialogue: 0,0:02:02.94,0:02:06.06,English,,0,0,0,,rather it claimed to convert the code into something called P-Code.
Dialogue: 0,0:02:06.06,0:02:08.56,English,,0,0,0,,And P-Code is just another interpreted language
Dialogue: 0,0:02:08.56,0:02:12.06,English,,0,0,0,,but it happens to be much more optimized for speed.
Dialogue: 0,0:02:12.06,0:02:16.02,English,,0,0,0,,If you try to list a program after compiling it, it will just say Blitz! Like this.
Dialogue: 0,0:02:16.02,0:02:18.92,English,,0,0,0,,So the code is no longer editable as BASIC,
Dialogue: 0,0:02:18.92,0:02:22.63,English,,0,0,0,,and I think that’s why the common belief was that it was machine language.
Dialogue: 0,0:02:22.63,0:02:26.90,English,,0,0,0,,But anyway, as you can see, if you compare the original program written in BASIC
Dialogue: 0,0:02:26.90,0:02:31.40,English,,0,0,0,,to the one that was Blitzed, clearly the Blitz version runs much faster.
Dialogue: 0,0:02:31.40,0:02:35.31,English,,0,0,0,,It’s still nowhere nearly as fast as machine language. With Blitz!,
Dialogue: 0,0:02:35.31,0:02:39.25,English,,0,0,0,,typical results can be anywhere from twice as fast to maybe 8 times as fast
Dialogue: 0,0:02:39.25,0:02:41.14,English,,0,0,0,,depending on what instructions you are using.
Dialogue: 0,0:02:41.14,0:02:43.97,English,,0,0,0,,So, how does this work? Well, for illustration,
Dialogue: 0,0:02:43.97,0:02:48.62,English,,0,0,0,,let’s take a look at this sample BASIC program, and let’s see how Blitz would optimize it.
Dialogue: 0,0:02:48.62,0:02:51.02,English,,0,0,0,,Well, for starters, any REM statements can be eliminated.
Dialogue: 0,0:02:51.02,0:02:53.42,English,,0,0,0,,I mean, these are only here as comments in the code,
Dialogue: 0,0:02:53.42,0:02:56.74,English,,0,0,0,,but they take up space and slightly slow down execution.
Dialogue: 0,0:02:56.74,0:02:59.91,English,,0,0,0,,And since the program can’t be edited anymore, might as well just delete it.
Dialogue: 0,0:03:00.58,0:03:03.59,English,,0,0,0,,The next thing we can do is have a look at where all of the BASIC lines
Dialogue: 0,0:03:03.59,0:03:07.60,English,,0,0,0,,are actually stored in RAM and make note of their actual memory addresses.
Dialogue: 0,0:03:08.00,0:03:10.97,English,,0,0,0,,And then we can look at anything that points to a line number,
Dialogue: 0,0:03:10.97,0:03:13.60,English,,0,0,0,,such as a GOTO, GOSUB, or even a NEXT statement,
Dialogue: 0,0:03:13.60,0:03:16.44,English,,0,0,0,,and figure out what it is they are pointing it.
Dialogue: 0,0:03:16.44,0:03:18.57,English,,0,0,0,,Normally, this is done during execution,
Dialogue: 0,0:03:18.57,0:03:21.49,English,,0,0,0,,which takes time to look up the line number and find it’s memory address.
Dialogue: 0,0:03:21.80,0:03:23.42,English,,0,0,0,,So, to speed things up, you can actually
Dialogue: 0,0:03:23.42,0:03:26.21,English,,0,0,0,,replace the line numbers with actual memory addresses,
Dialogue: 0,0:03:26.21,0:03:28.65,English,,0,0,0,,so no lookups will be done during execution.
Dialogue: 0,0:03:28.65,0:03:30.92,English,,0,0,0,,and, of course, we no longer need the line numbers,
Dialogue: 0,0:03:30.92,0:03:33.22,English,,0,0,0,,so they can actually be removed from the code completely.
Dialogue: 0,0:03:33.73,0:03:36.25,English,,0,0,0,,OK, so here’s another thing that could use optimization.
Dialogue: 0,0:03:36.25,0:03:38.41,English,,0,0,0,,Numbers like this stored in BASIC
Dialogue: 0,0:03:38.41,0:03:41.94,English,,0,0,0,,are actually stored as raw text characters, a string if you will.
Dialogue: 0,0:03:41.94,0:03:46.65,English,,0,0,0,,So, a number like 53280 is actually stored as 5 separate bytes.
Dialogue: 0,0:03:46.65,0:03:48.15,English,,0,0,0,,You can actually see this if you look at
Dialogue: 0,0:03:48.15,0:03:50.08,English,,0,0,0,,a BASIC program in a machine language monitor.
Dialogue: 0,0:03:50.57,0:03:52.32,English,,0,0,0,,Well, the trouble is, these numbers have to be
Dialogue: 0,0:03:52.32,0:03:55.25,English,,0,0,0,,converted from strings to numbers during execution.
Dialogue: 0,0:03:55.25,0:03:58.25,English,,0,0,0,,So again, we can go ahead and convert them now,
Dialogue: 0,0:03:58.25,0:04:00.88,English,,0,0,0,,that way it saves time when the program is executing.
Dialogue: 0,0:04:01.16,0:04:03.65,English,,0,0,0,,And so, these are the types of enhancements that Blitz
Dialogue: 0,0:04:03.65,0:04:06.44,English,,0,0,0,,or similar programs would do to speed up your BASIC programs,
Dialogue: 0,0:04:06.44,0:04:08.84,English,,0,0,0,,but they are still essentially BASIC programs,
Dialogue: 0,0:04:08.84,0:04:13.24,English,,0,0,0,,they are still being interpreted at time of execution, definitely not machine language.
Dialogue: 0,0:04:13.24,0:04:15.70,English,,0,0,0,,But there isn’t necessarily anything wrong with this,
Dialogue: 0,0:04:15.70,0:04:17.52,English,,0,0,0,,if you were good at programming in BASIC,
Dialogue: 0,0:04:17.52,0:04:20.82,English,,0,0,0,,then this certainly gave you an option for some extra speed.
Dialogue: 0,0:04:20.82,0:04:23.45,English,,0,0,0,,So, then, what is machine language?
Dialogue: 0,0:04:23.45,0:04:26.27,English,,0,0,0,,Well, this is the language that is native to your microprocessor.
Dialogue: 0,0:04:26.27,0:04:28.36,English,,0,0,0,,This is the only language it knows.
Dialogue: 0,0:04:28.36,0:04:31.17,English,,0,0,0,,And every single piece of software you run on your computer,
Dialogue: 0,0:04:31.17,0:04:35.34,English,,0,0,0,,whether it is a vintage computer, or a modern computer, has to be in machine language
Dialogue: 0,0:04:35.34,0:04:37.58,English,,0,0,0,,or your CPU won’t know how to execute it.
Dialogue: 0,0:04:37.58,0:04:40.70,English,,0,0,0,,Which means, if you ware writing code in some other language,
Dialogue: 0,0:04:40.70,0:04:43.17,English,,0,0,0,,it will need to be converted into machine language.
Dialogue: 0,0:04:43.17,0:04:44.98,English,,0,0,0,,There are two ways this can happen.
Dialogue: 0,0:04:45.49,0:04:50.55,English,,0,0,0,,Languages like BASIC, Java, Python, Ruby, and Perl are all interpreted languages.
Dialogue: 0,0:04:50.55,0:04:53.86,English,,0,0,0,,That means they need a separate piece of software called an interpreter,
Dialogue: 0,0:04:53.86,0:04:56.45,English,,0,0,0,,or sometimes called a run-time-environment, which will
Dialogue: 0,0:04:56.45,0:04:58.38,English,,0,0,0,,look at your code one instruction at a time,
Dialogue: 0,0:04:58.38,0:05:02.17,English,,0,0,0,,and then convert that into machine language instructions for your CPU.
Dialogue: 0,0:05:02.17,0:05:05.37,English,,0,0,0,,This interpreter must always be present for your code to work.
Dialogue: 0,0:05:05.37,0:05:09.74,English,,0,0,0,,Interpreted code also tends to be the slowest type of code in terms of performance,
Dialogue: 0,0:05:09.74,0:05:12.22,English,,0,0,0,,but also tends to have the easiest learning curve.
Dialogue: 0,0:05:12.80,0:05:17.82,English,,0,0,0,,On the flip side, languages like C++, Pascal, C#, Cobol, and Assembly language
Dialogue: 0,0:05:17.82,0:05:19.75,English,,0,0,0,,are run through a compiler, which actually
Dialogue: 0,0:05:19.75,0:05:22.97,English,,0,0,0,,transforms the code into machine language permanently.
Dialogue: 0,0:05:22.97,0:05:27.54,English,,0,0,0,,Once this process is finished, you no longer need the compiler for the program to run,
Dialogue: 0,0:05:27.54,0:05:30.68,English,,0,0,0,,although you might need it if you ever want to make changes to the code.
Dialogue: 0,0:05:30.68,0:05:34.68,English,,0,0,0,,These types of programs tend to have much better performance than interpreted languages,
Dialogue: 0,0:05:34.68,0:05:37.34,English,,0,0,0,,but as mentioned before might have a bit higher learning curve.
Dialogue: 0,0:05:37.83,0:05:40.25,English,,0,0,0,,Now, before you race to the comment section
Dialogue: 0,0:05:40.25,0:05:42.71,English,,0,0,0,,to tell me how I’m wrong about Java or C#,
Dialogue: 0,0:05:43.34,0:05:45.91,English,,0,0,0,,please understand that I’m making a generalization here
Dialogue: 0,0:05:45.91,0:05:48.80,English,,0,0,0,,and I do understand it isn’t quite this black and white.
Dialogue: 0,0:05:48.80,0:05:53.11,English,,0,0,0,,The point is, it has to be converted to machine language somewhere along the way.
Dialogue: 0,0:05:53.37,0:05:55.78,English,,0,0,0,,So, what does machine language look like?
Dialogue: 0,0:05:55.78,0:05:57.88,English,,0,0,0,,Well, at it’s core it’s just a bunch of numbers.
Dialogue: 0,0:05:57.88,0:06:02.35,English,,0,0,0,,This small program is an example program that flashes the border on a Commodore 128.
Dialogue: 0,0:06:02.35,0:06:06.91,English,,0,0,0,,The first number here is a CPU command, or instruction, or Op-code, if you will.
Dialogue: 0,0:06:06.91,0:06:10.60,English,,0,0,0,,It commands the CPU to increment a number somewhere in memory.
Dialogue: 0,0:06:10.60,0:06:14.31,English,,0,0,0,,And the next two numbers are the memory address that needs to be incremented.
Dialogue: 0,0:06:14.31,0:06:17.91,English,,0,0,0,,The next number is another instruction, this time telling the CPU to Jump,
Dialogue: 0,0:06:17.91,0:06:20.91,English,,0,0,0,,or goto some other place in memory to continue execution.
Dialogue: 0,0:06:20.91,0:06:23.12,English,,0,0,0,,And of course, the two numbers following that instruction
Dialogue: 0,0:06:23.12,0:06:25.91,English,,0,0,0,,represent the memory address it’s going to jump to.
Dialogue: 0,0:06:25.91,0:06:29.05,English,,0,0,0,,This is actually how early coding was done on computers
Dialogue: 0,0:06:29.05,0:06:31.55,English,,0,0,0,,like the Altair with it’s panel of switches on the front panel,
Dialogue: 0,0:06:31.55,0:06:33.71,English,,0,0,0,,or computers like the KIM-1.
Dialogue: 0,0:06:34.08,0:06:36.91,English,,0,0,0,,Now, if that seems confusing to you and you’re thinking
Dialogue: 0,0:06:36.91,0:06:40.68,English,,0,0,0,,“How on earth would anyone write complex programs in machine language?”
Dialogue: 0,0:06:40.68,0:06:45.31,English,,0,0,0,,Well, the reality is, nobody did. Or at least not since the 1970s.
Dialogue: 0,0:06:45.31,0:06:47.85,English,,0,0,0,,And I gave you this example, not to scare you away,
Dialogue: 0,0:06:47.85,0:06:53.28,English,,0,0,0,,but rather to help differentiate between machine language and assembly language.
Dialogue: 0,0:06:53.28,0:06:55.35,English,,0,0,0,,These two terms are often used interchangeably,
Dialogue: 0,0:06:55.35,0:06:58.61,English,,0,0,0,,and while they are closely related, they’re not exactly the same thing.
Dialogue: 0,0:06:58.97,0:07:02.51,English,,0,0,0,,It’s sort of like the difference between music, and musical score.
Dialogue: 0,0:07:02.51,0:07:05.60,English,,0,0,0,,They are very much related, and there is a one-to-one ratio
Dialogue: 0,0:07:05.60,0:07:07.87,English,,0,0,0,,between the notes you hear and what is written on the paper.
Dialogue: 0,0:07:07.87,0:07:10.17,English,,0,0,0,,But they aren’t exactly the same thing.
Dialogue: 0,0:07:10.17,0:07:12.52,English,,0,0,0,,And since I can’t think of a really good way to explain it,
Dialogue: 0,0:07:12.52,0:07:14.60,English,,0,0,0,,I figure the best thing to do is just show you.
Dialogue: 0,0:07:14.60,0:07:19.20,English,,0,0,0,,But first, I want to write a small program in BASIC. This program also flashes the border.
Dialogue: 0,0:07:19.20,0:07:21.45,English,,0,0,0,,And I think this will help illustrate a few things.
Dialogue: 0,0:07:21.45,0:07:23.45,English,,0,0,0,,It’s just going to count from 0 to 255
Dialogue: 0,0:07:23.45,0:07:25.62,English,,0,0,0,,and then write that number to the screen border register.
Dialogue: 0,0:07:25.62,0:07:28.40,English,,0,0,0,,And then we’re just going to repeat this indefinitely.
Dialogue: 0,0:07:28.40,0:07:30.85,English,,0,0,0,,Now, this looks like it’s going pretty fast.
Dialogue: 0,0:07:30.85,0:07:33.77,English,,0,0,0,,In fact, the border is changing faster than the screen is drawn,
Dialogue: 0,0:07:33.77,0:07:36.82,English,,0,0,0,,that’s why the border appears more than one color in places.
Dialogue: 0,0:07:36.82,0:07:39.27,English,,0,0,0,,So, that’s pretty fast right?
Dialogue: 0,0:07:39.27,0:07:43.85,English,,0,0,0,,Well, now let’s write the same program in assembly language using the built in monitor.
Dialogue: 0,0:07:43.85,0:07:47.77,English,,0,0,0,,So, we’re going to start our program at memory location 1300 hex.
Dialogue: 0,0:07:47.77,0:07:50.37,English,,0,0,0,,We’re going to increase the color value in the screen border.
Dialogue: 0,0:07:50.37,0:07:55.50,English,,0,0,0,,So, this D020 here is the exact same number as this 53280 we used in BASIC.
Dialogue: 0,0:07:55.50,0:07:58.30,English,,0,0,0,,Just one is represented in decimal and the other one in hexadecimal.
Dialogue: 0,0:07:58.30,0:08:00.05,English,,0,0,0,,Also, see these 3 numbers here,
Dialogue: 0,0:08:00.05,0:08:03.18,English,,0,0,0,,these are the actual machine code that is being stored in RAM.
Dialogue: 0,0:08:03.18,0:08:07.38,English,,0,0,0,,The stuff to the right is just the human-readable form of that, which we call assembly.
Dialogue: 0,0:08:07.38,0:08:12.08,English,,0,0,0,,Anyway, our next instruction is JMP, which is similar to the GOTO statement in BASIC.
Dialogue: 0,0:08:12.08,0:08:16.30,English,,0,0,0,,And we’re going to jump to 1300, which takes us right back here in an infinite loop.
Dialogue: 0,0:08:16.30,0:08:20.22,English,,0,0,0,,So, this program is actually simpler and smaller than the BASIC code we wrote.
Dialogue: 0,0:08:20.84,0:08:25.40,English,,0,0,0,,OK, so let’s exit the monitor back to BASIC and I’ll start the code by typing SYS,
Dialogue: 0,0:08:25.40,0:08:27.78,English,,0,0,0,,which in Commodore BASIC calls a machine language program,
Dialogue: 0,0:08:27.78,0:08:32.50,English,,0,0,0,,and the address is 4864, which is the same as 1300 hex.
Dialogue: 0,0:08:32.50,0:08:36.46,English,,0,0,0,,And so, there it is. So, this is actually running so fast that the border is
Dialogue: 0,0:08:36.46,0:08:40.89,English,,0,0,0,,changing every few pixels of drawing the screen, making the thing look like this weird pattern.
Dialogue: 0,0:08:40.90,0:08:45.14,English,,0,0,0,,So, I’m going to give you one more example program here. Again, we’ll start in BASIC.
Dialogue: 0,0:08:45.14,0:08:48.02,English,,0,0,0,,And what we’re going to do is count from 0 to 255 again,
Dialogue: 0,0:08:48.02,0:08:51.60,English,,0,0,0,,and we’re going to display all 255 characters on the screen.
Dialogue: 0,0:08:51.88,0:08:54.44,English,,0,0,0,,Screen memory starts at memory address 1024.
Dialogue: 0,0:08:55.32,0:08:58.50,English,,0,0,0,,And that should do it. And let’s see how long it takes to execute this code.
Dialogue: 0,0:08:59.20,0:09:02.72,English,,0,0,0,,OK, about 3 or 4 seconds. So, that’s not too bad, right?
Dialogue: 0,0:09:03.64,0:09:06.26,English,,0,0,0,,OK, so now lets do the same code in the monitor.
Dialogue: 0,0:09:06.26,0:09:09.04,English,,0,0,0,,This is just a few lines so I’ll walk you through the code.
Dialogue: 0,0:09:09.04,0:09:11.88,English,,0,0,0,, Now, don’t worry if you don’t understand all of this, I think you’ll get the gist of it.
Dialogue: 0,0:09:12.22,0:09:18.08,English,,0,0,0,,LDX means Load X with Zero. This just sets the value of the X register to zero.
Dialogue: 0,0:09:18.08,0:09:21.40,English,,0,0,0,,Next, TXA means Transfer X to the accumulator.
Dialogue: 0,0:09:21.40,0:09:25.30,English,,0,0,0,,Now STA means to store the accumulator at 400,
Dialogue: 0,0:09:25.30,0:09:27.82,English,,0,0,0,,which is the start of screen RAM in hexadecimal.
Dialogue: 0,0:09:27.82,0:09:33.14,English,,0,0,0,,The comma-X at the end means we’ll add the value of X to the address before the save.
Dialogue: 0,0:09:33.14,0:09:35.74,English,,0,0,0,,INX means to increase X by one.
Dialogue: 0,0:09:35.74,0:09:37.62,English,,0,0,0,,Then we’re going to compare X to zero.
Dialogue: 0,0:09:37.62,0:09:40.54,English,,0,0,0,,The reason we do zero is that if the value is 255
Dialogue: 0,0:09:40.54,0:09:45.10,English,,0,0,0,,and you increase by one, it will wrap around to zero again since this is an 8-bit system.
Dialogue: 0,0:09:45.16,0:09:50.36,English,,0,0,0,,Now that we’ve compared, we’ll tell the CPU to branch if not equal back to 1302.
Dialogue: 0,0:09:50.36,0:09:53.82,English,,0,0,0,,If it is equal, then RTS will tell it to return back to BASIC.
Dialogue: 0,0:09:54.68,0:09:57.66,English,,0,0,0,,So, there we go, pretty simple. So, let’s execute the code.
Dialogue: 0,0:09:57.94,0:10:00.67,English,,0,0,0,,And as you can see, it is so fast that
Dialogue: 0,0:10:00.67,0:10:03.73,English,,0,0,0,,it’s actually finished before I even lift my finger off of the return key.
Dialogue: 0,0:10:04.02,0:10:06.00,English,,0,0,0,,So, I’ll show you that again, one more time.
Dialogue: 0,0:10:06.52,0:10:08.30,English,,0,0,0,,So now that you’ve seen assembly language,
Dialogue: 0,0:10:08.30,0:10:10.66,English,,0,0,0,,I’d love to show you this little scene from the Terminator.
Dialogue: 0,0:10:10.66,0:10:14.08,English,,0,0,0,,What you are seeing here is assembly language, and more specifically
Dialogue: 0,0:10:14.08,0:10:16.92,English,,0,0,0,,and more specifically 6502 assembly language from an Apple II.
Dialogue: 0,0:10:16.92,0:10:19.46,English,,0,0,0,,Not many people today would recognize this.
Dialogue: 0,0:10:20.24,0:10:23.44,English,,0,0,0,,So, why is Assembly so much faster than BASIC?
Dialogue: 0,0:10:23.44,0:10:25.71,English,,0,0,0,,Well, as mentioned before, BASIC is interpreted.
Dialogue: 0,0:10:25.71,0:10:28.22,English,,0,0,0,,So for every BASIC command you see here,
Dialogue: 0,0:10:28.22,0:10:31.82,English,,0,0,0,,hundreds of machine language instructions are happening to carry it out.
Dialogue: 0,0:10:31.82,0:10:34.00,English,,0,0,0,,As such, a program in machine language will run
Dialogue: 0,0:10:34.00,0:10:37.10,English,,0,0,0,,at least a hundred times faster than anything you can write in BASIC.
Dialogue: 0,0:10:37.10,0:10:39.35,English,,0,0,0,,Now, it is at this point I think I should stop and mention to you
Dialogue: 0,0:10:39.35,0:10:41.92,English,,0,0,0,,that there is more than one kind of machine language.
Dialogue: 0,0:10:41.92,0:10:44.94,English,,0,0,0,,Now, when you write code in like C or Python, there’s
Dialogue: 0,0:10:44.94,0:10:48.06,English,,0,0,0,,a good chance that code is going to run on any computer with any CPU.
Dialogue: 0,0:10:48.06,0:10:52.38,English,,0,0,0,,But, machine language is very dependent on the CPU that you are coding for.
Dialogue: 0,0:10:52.38,0:10:56.14,English,,0,0,0,,So, code written on a 6502, for example, will not run on a Z80.
Dialogue: 0,0:10:56.14,0:10:58.14,English,,0,0,0,,They are very different languages.
Dialogue: 0,0:10:58.14,0:11:01.15,English,,0,0,0,,But for the purposes of this video, I’m going to stick with the 6502
Dialogue: 0,0:11:01.15,0:11:03.69,English,,0,0,0,,because I think it’s one of the simplest to understand.
Dialogue: 0,0:11:03.69,0:11:09.72,English,,0,0,0,,The 6502 CPU has 151 op-codes. But, it’s really not that many in practice.
Dialogue: 0,0:11:09.72,0:11:12.90,English,,0,0,0,,In fact, you only need to remember 56 instructions.
Dialogue: 0,0:11:12.90,0:11:15.12,English,,0,0,0,,For example, if you are using the command LDA,
Dialogue: 0,0:11:15.12,0:11:17.22,English,,0,0,0,,which means to load a number into the accumulator.
Dialogue: 0,0:11:17.22,0:11:20.58,English,,0,0,0,,You can tell it to load a specific number like 42,
Dialogue: 0,0:11:20.58,0:11:23.96,English,,0,0,0,,or you can tell it to load the number from a specific memory address like this.
Dialogue: 0,0:11:23.96,0:11:28.42,English,,0,0,0,,As you can see, looking over to the left here, the actual CPU op-codes are different,
Dialogue: 0,0:11:28.42,0:11:31.04,English,,0,0,0,,but as a human, you don’t really need to know the difference
Dialogue: 0,0:11:31.04,0:11:34.39,English,,0,0,0,,as your assembler will take care of figuring out which op-code to use.
Dialogue: 0,0:11:34.39,0:11:37.52,English,,0,0,0,,Now, what I shown so far has been using a machine language monitor,
Dialogue: 0,0:11:37.52,0:11:39.92,English,,0,0,0,,which allows you to look at and modify machine code.
Dialogue: 0,0:11:39.92,0:11:42.80,English,,0,0,0,,But you wouldn’t want to really write any sort of code in this
Dialogue: 0,0:11:42.80,0:11:44.46,English,,0,0,0,,that was longer than just a few lines.
Dialogue: 0,0:11:44.46,0:11:48.50,English,,0,0,0,,Because you’d have to remember a ton of memory addresses for every sub-routine.
Dialogue: 0,0:11:48.50,0:11:52.30,English,,0,0,0,,But the worst part is there is no easy way to insert a line of code.
Dialogue: 0,0:11:52.30,0:11:54.83,English,,0,0,0,,Generally you can only overwrite a line.
Dialogue: 0,0:11:54.83,0:11:57.50,English,,0,0,0,,That’s where using a compiler comes in handy.
Dialogue: 0,0:11:57.50,0:12:00.86,English,,0,0,0,,So, here’s some of my source code for my recent game, Attack of the PETSCII Robots.
Dialogue: 0,0:12:00.86,0:12:03.20,English,,0,0,0,,As you can see, this is written in a text editor,
Dialogue: 0,0:12:03.20,0:12:06.54,English,,0,0,0,,and looks far more friendly, with subroutines that have friendly names
Dialogue: 0,0:12:06.54,0:12:09.36,English,,0,0,0,,like “search object” or “display player sprite.”
Dialogue: 0,0:12:09.36,0:12:14.10,English,,0,0,0,,And this is where an assembler makes life so much easier. So, how does this work?
Dialogue: 0,0:12:14.64,0:12:17.28,English,,0,0,0,,Well, here’s a very short little example program written in a notepad.
Dialogue: 0,0:12:17.28,0:12:19.72,English,,0,0,0,,Now, after compiling the program I’m going to open it up
Dialogue: 0,0:12:19.72,0:12:22.08,English,,0,0,0,,in the machine language monitor and see what it looks like.
Dialogue: 0,0:12:22.08,0:12:26.62,English,,0,0,0,,So, the first thing I want to mention is that the actual instructions are preserved one to one.
Dialogue: 0,0:12:26.62,0:12:28.92,English,,0,0,0,,There’s absolutely no difference here.
Dialogue: 0,0:12:28.92,0:12:31.52,English,,0,0,0,,However, our friendly label such as “screen RAM”
Dialogue: 0,0:12:31.52,0:12:34.06,English,,0,0,0,,has been converted to the actual memory address for us.
Dialogue: 0,0:12:34.06,0:12:36.15,English,,0,0,0,,Likewise, the labels I used for the loop,
Dialogue: 0,0:12:36.15,0:12:38.60,English,,0,0,0,,have also been converted into the actual memory address,
Dialogue: 0,0:12:38.60,0:12:42.60,English,,0,0,0,,which, of course, corresponds to the exact place in the code where it is supposed to point to.
Dialogue: 0,0:12:42.60,0:12:45.68,English,,0,0,0,,And, of course, if you just wanted to see the resulting machine code itself,
Dialogue: 0,0:12:45.68,0:12:47.08,English,,0,0,0,,you can look at that as well.
Dialogue: 0,0:12:47.58,0:12:50.35,English,,0,0,0,,And so I hope this better explains the difference between this,
Dialogue: 0,0:12:50.35,0:12:55.20,English,,0,0,0,,which is machine code or machine language, and this, which is assembly language.
Dialogue: 0,0:12:55.20,0:12:58.30,English,,0,0,0,,They are really just two different ways of looking at the same thing.
Dialogue: 0,0:12:58.30,0:13:02.08,English,,0,0,0,,And while back in the early days, some coders did have to write software in machine language,
Dialogue: 0,0:13:02.08,0:13:06.68,English,,0,0,0,,the vast majority used an assembler to write code that is more human-readable.
Dialogue: 0,0:13:07.16,0:13:09.42,English,,0,0,0,,So, one thing you might be wondering about is
Dialogue: 0,0:13:09.42,0:13:12.54,English,,0,0,0,,why everything in assembly language uses hexadecimal?
Dialogue: 0,0:13:12.54,0:13:15.82,English,,0,0,0,,So, I want to explain a few things about it. For those that don’t know,
Dialogue: 0,0:13:15.82,0:13:18.70,English,,0,0,0,,it is a numbering system that is based on 16 digits instead of 10,
Dialogue: 0,0:13:18.70,0:13:22.12,English,,0,0,0,,and it just adds A,B,C,D,E, and F for the extra 6 digits.
Dialogue: 0,0:13:22.12,0:13:25.72,English,,0,0,0,,The reason this is handy is because when dealing with byte sized numbers,
Dialogue: 0,0:13:25.72,0:13:29.12,English,,0,0,0,,a single hex digit can represent 4 bits of your byte,
Dialogue: 0,0:13:29.12,0:13:31.07,English,,0,0,0,,which is actually called a nybble by the way.
Dialogue: 0,0:13:31.07,0:13:35.90,English,,0,0,0,,So, 9A is much easier to read than the decimal form of 154.
Dialogue: 0,0:13:36.52,0:13:39.27,English,,0,0,0,,A possibly better example would be looking at memory addresses,
Dialogue: 0,0:13:39.27,0:13:41.62,English,,0,0,0,,which is something you do a lot in assembly language.
Dialogue: 0,0:13:41.62,0:13:47.70,English,,0,0,0,,In decimal, the 64K memory range of a CPU would be represented from 0 to 65535.
Dialogue: 0,0:13:47.70,0:13:50.90,English,,0,0,0,,But, in hex it is a much cleaner 0 to FFFF.
Dialogue: 0,0:13:50.90,0:13:55.45,English,,0,0,0,,But where things get really interesting is when looking at a memory address in terms of bytes.
Dialogue: 0,0:13:55.45,0:13:58.05,English,,0,0,0,,So here’s the same address in Hex and Decimal.
Dialogue: 0,0:13:58.05,0:14:01.32,English,,0,0,0,,You might recognize this as the border color address on a Commodore 64,
Dialogue: 0,0:14:01.32,0:14:04.00,English,,0,0,0,,which you can use a POKE statement to change the border color.
Dialogue: 0,0:14:04.00,0:14:08.40,English,,0,0,0,,Well, in assembly language this address has to be represented by exactly two bytes.
Dialogue: 0,0:14:08.40,0:14:13.92,English,,0,0,0,,And in hexadecimal, those two bytes are D0, and 20. Which, makes total sense.
Dialogue: 0,0:14:13.92,0:14:20.72,English,,0,0,0,,But in decimal, those two bytes are 208 and 32. Which doesn’t appear to make any sense at all.
Dialogue: 0,0:14:20.72,0:14:23.42,English,,0,0,0,,In fact, you have to do some math to actually see that this is right.
Dialogue: 0,0:14:23.42,0:14:27.75,English,,0,0,0,,You’ll need to multiply 208 by 256, which gives you 53248,
Dialogue: 0,0:14:27.75,0:14:31.82,English,,0,0,0,,and then add in your 32 from the lower byte and then you get your final number.
Dialogue: 0,0:14:31.82,0:14:34.22,English,,0,0,0,,So, as you can see, programers find it much easier
Dialogue: 0,0:14:34.22,0:14:36.85,English,,0,0,0,,just to deal with things like this in hexadecimal.
Dialogue: 0,0:14:37.50,0:14:39.97,English,,0,0,0,,And of course, if they use hexadecimal on Logopolis,
Dialogue: 0,0:14:39.97,0:14:42.89,English,,0,0,0,,that’s all the proof you need that it’s the best system for computers!
Dialogue: 0,0:14:45.12,0:14:50.22,English,,0,0,0,,9A, E7, E9, sorry, E9, 23, wait wait, did you say say E9? Look it says E7 there!
Dialogue: 0,0:14:51.67,0:14:53.20,English,,0,0,0,,You’re right!
Dialogue: 0,0:14:53.20,0:14:56.53,English,,0,0,0,,One last thing about hexadecimal I wanted to mention is how it is represented.
Dialogue: 0,0:14:56.53,0:14:59.80,English,,0,0,0,,I’ve been showing it with a dollar sign in front of it like this, which is
Dialogue: 0,0:14:59.80,0:15:05.15,English,,0,0,0,,the normal way to identify it in 6502 assembly language, PASCAL, Delphi, and Forth.
Dialogue: 0,0:15:05.15,0:15:09.27,English,,0,0,0,,But, another way to represent it is to put a zero X in front of it like this,
Dialogue: 0,0:15:09.27,0:15:15.27,English,,0,0,0,,which is common in 8088 assembly language, C++, C#, Java, Python, and many others.
Dialogue: 0,0:15:15.27,0:15:17.17,English,,0,0,0,,The numbers work exactly the same,
Dialogue: 0,0:15:17.17,0:15:20.30,English,,0,0,0,,it’s just a different way of designating it as hex in the compiler.
Dialogue: 0,0:15:20.30,0:15:23.17,English,,0,0,0,,Assembly language in and of itself is not that difficult.
Dialogue: 0,0:15:23.17,0:15:24.87,English,,0,0,0,,In fact, there are certain things that are actually
Dialogue: 0,0:15:24.87,0:15:27.60,English,,0,0,0,,easier to do in assembly language such as graphics programming.
Dialogue: 0,0:15:27.60,0:15:31.57,English,,0,0,0,,But there are some tradeoffs. And there are certain things that are kind of a pain.
Dialogue: 0,0:15:31.57,0:15:36.02,English,,0,0,0,,For example, working with strings. That’s a nightmare to work with in assembly language.
Dialogue: 0,0:15:36.02,0:15:40.17,English,,0,0,0,,However, I think the thing that often makes assembly language more difficult
Dialogue: 0,0:15:40.17,0:15:44.65,English,,0,0,0,,is the fact that you have to know how the hardware works that you’re coding for.
Dialogue: 0,0:15:44.65,0:15:48.17,English,,0,0,0,,With assembly language, and in the example of the 6502 processor,
Dialogue: 0,0:15:48.17,0:15:51.30,English,,0,0,0,,you have your 56 instructions, and all of these more or less
Dialogue: 0,0:15:51.30,0:15:54.50,English,,0,0,0,,have to do with moving numbers around in memory.
Dialogue: 0,0:15:54.50,0:15:56.30,English,,0,0,0,,So, how do you actually do things like
Dialogue: 0,0:15:56.30,0:15:59.16,English,,0,0,0,,modify things on the screen or make music, for example?
Dialogue: 0,0:15:59.16,0:16:04.15,English,,0,0,0,,Well, every chip in the computer presents itself as memory of some sort to the CPU.
Dialogue: 0,0:16:04.15,0:16:07.82,English,,0,0,0,,So, in the C64 for example, the video chip presents itself as
Dialogue: 0,0:16:07.82,0:16:12.77,English,,0,0,0,,47 different memory addresses starting from $D000 to $D02E.
Dialogue: 0,0:16:12.77,0:16:15.52,English,,0,0,0,,When it is not memory, we tend to call them registers.
Dialogue: 0,0:16:15.52,0:16:18.77,English,,0,0,0,,But from the perspective of the CPU, it can’t tell the difference.
Dialogue: 0,0:16:18.77,0:16:21.82,English,,0,0,0,,So, when we write a number to the border color register, for example,
Dialogue: 0,0:16:21.82,0:16:24.52,English,,0,0,0,,the CPU just thinks it is just updating a number in memory,
Dialogue: 0,0:16:24.52,0:16:28.45,English,,0,0,0,,but what is really happening it’s updating a register in the video chip.
Dialogue: 0,0:16:28.45,0:16:31.62,English,,0,0,0,,So, as a programmer, you’d have to make yourself familiar with
Dialogue: 0,0:16:31.62,0:16:34.83,English,,0,0,0,,all of the registers in every chip on the computer and how they work.
Dialogue: 0,0:16:34.83,0:16:37.72,English,,0,0,0,,And of course, when you move from one computer, like the C64
Dialogue: 0,0:16:37.72,0:16:40.10,English,,0,0,0,,over to another computer such as the Apple II,
Dialogue: 0,0:16:40.10,0:16:42.00,English,,0,0,0,,even though they use the same processor,
Dialogue: 0,0:16:42.00,0:16:44.00,English,,0,0,0,,everything else is completely different.
Dialogue: 0,0:16:44.00,0:16:48.63,English,,0,0,0,,That’s why it can be incredibly difficult to port a game from one machine to another.
Dialogue: 0,0:16:48.63,0:16:51.97,English,,0,0,0,,I think that’s why people are often confused when they see that I’ve written these games
Dialogue: 0,0:16:51.97,0:16:54.52,English,,0,0,0,,like Planet X3, or Attack of the Petscii Robots,
Dialogue: 0,0:16:54.52,0:16:58.22,English,,0,0,0,,and they want me to make a version for their favorite computer.
Dialogue: 0,0:16:58.22,0:17:03.52,English,,0,0,0,,Now even going between systems that share the same CPU, it’s still a pretty big undertaking.
Dialogue: 0,0:17:03.52,0:17:06.72,English,,0,0,0,,In fact, there’s a small team of Apple II guys that have been working to
Dialogue: 0,0:17:06.72,0:17:09.02,English,,0,0,0,,convert Petscii Robots over to the Apple II
Dialogue: 0,0:17:09.02,0:17:11.50,English,,0,0,0,,and as you can see, it is mostly working now.
Dialogue: 0,0:17:11.50,0:17:14.95,English,,0,0,0,,Keep in mind the Apple II has the same CPU as Commodore systems,
Dialogue: 0,0:17:14.95,0:17:18.90,English,,0,0,0,,so a huge amount of the code is re-usable between these systems.
Dialogue: 0,0:17:18.90,0:17:23.07,English,,0,0,0,,But it’s still a massive undertaking to re-write all of the audio and video sub-routines.
Dialogue: 0,0:17:23.07,0:17:24.37,English,,0,0,0,,But then when people suggest that
Dialogue: 0,0:17:24.37,0:17:27.40,English,,0,0,0,,I make a version of my game for system that uses a different CPU,
Dialogue: 0,0:17:27.40,0:17:31.67,English,,0,0,0,,for example asking me to make an Amiga or ZX spectrum version or something like that,
Dialogue: 0,0:17:31.67,0:17:34.62,English,,0,0,0,,at that point it becomes a complete rewrite.
Dialogue: 0,0:17:34.62,0:17:39.27,English,,0,0,0,,So, it’s no small task. I mean, if it took me a year to write the game in the first place,
Dialogue: 0,0:17:39.27,0:17:43.91,English,,0,0,0,,then it would take me another year to basically write the whole game again from scratch.
Dialogue: 0,0:17:43.91,0:17:45.50,English,,0,0,0,,And I think this is where a lot of people are
Dialogue: 0,0:17:45.50,0:17:47.45,English,,0,0,0,,spoiled by modern programming languages because
Dialogue: 0,0:17:47.45,0:17:50.25,English,,0,0,0,,if you write something in C or Python, fundamentally
Dialogue: 0,0:17:50.25,0:17:52.15,English,,0,0,0,,you can expect that same code is probably
Dialogue: 0,0:17:52.15,0:17:54.90,English,,0,0,0,,going to run across multiple different CPUs on multiple different systems,
Dialogue: 0,0:17:54.90,0:17:56.82,English,,0,0,0,,on multiple different memory configurations.
Dialogue: 0,0:17:56.82,0:17:59.20,English,,0,0,0,,Machine language basically goes one direction.
Dialogue: 0,0:17:59.20,0:18:02.62,English,,0,0,0,,You can compile a program from a higher level language into machine language.
Dialogue: 0,0:18:02.62,0:18:05.75,English,,0,0,0,,Or you can write in machine language to begin with, if you want.
Dialogue: 0,0:18:05.75,0:18:08.20,English,,0,0,0,,But you can’t go back the other direction.
Dialogue: 0,0:18:08.20,0:18:11.72,English,,0,0,0,,Much like you can convert notes on a sheet of music into a symphony.
Dialogue: 0,0:18:11.72,0:18:15.57,English,,0,0,0,,It’s much more difficult to convert the symphony back into notes.
Dialogue: 0,0:18:15.57,0:18:18.95,English,,0,0,0,,Another example would be scrambling an egg. It’s easy to do it one direction,
Dialogue: 0,0:18:18.95,0:18:21.54,English,,0,0,0,,but unscrambling is a different story.
Dialogue: 0,0:18:21.54,0:18:24.85,English,,0,0,0,,Today, Assembly language is more or less a lost art.
Dialogue: 0,0:18:24.85,0:18:27.62,English,,0,0,0,,Modern compilers are pretty good at creating
Dialogue: 0,0:18:27.62,0:18:30.50,English,,0,0,0,,optimized machine code from higher level languages.
Dialogue: 0,0:18:30.50,0:18:33.30,English,,0,0,0,,And computers are also just so darned fast that
Dialogue: 0,0:18:33.30,0:18:36.72,English,,0,0,0,,any speed loss you might have is pretty much negligible these days.
Dialogue: 0,0:18:36.72,0:18:40.37,English,,0,0,0,,I mean, even operating systems like the Linux kernel are written in C.
Dialogue: 0,0:18:40.37,0:18:45.05,English,,0,0,0,,So, assembly language today doesn’t really offer that much benefit for the modern coder.
Dialogue: 0,0:18:45.05,0:18:48.82,English,,0,0,0,,But if you want to write games for computers that were madden the 1970s or 80s,
Dialogue: 0,0:18:48.82,0:18:52.00,English,,0,0,0,,learning machine language is pretty much a must.
Dialogue: 0,0:18:52.00,0:18:54.92,English,,0,0,0,,And if you do learn it, you’ll probably wind up finding out
Dialogue: 0,0:18:54.92,0:18:58.37,English,,0,0,0,,a whole lot more information about how computers actually work.
Dialogue: 0,0:18:58.37,0:19:01.42,English,,0,0,0,,OK, one last thing I want to mention, if you’re looking around at the new studio
Dialogue: 0,0:19:01.42,0:19:02.32,English,,0,0,0,,and you’re thinking "well gee, David,
Dialogue: 0,0:19:02.32,0:19:04.47,English,,0,0,0,,this studio looks pretty boring compared to your old one!"
Dialogue: 0,0:19:04.85,0:19:07.07,English,,0,0,0,,Well, it’s actually not done yet.
Dialogue: 0,0:19:07.07,0:19:11.85,English,,0,0,0,,The problem is the old studio has already been dismantled so I didn’t have anywhere to film,
Dialogue: 0,0:19:11.85,0:19:15.32,English,,0,0,0,,so it had to be done in here. But yeah, I’m going to do a whole other follow up
Dialogue: 0,0:19:15.32,0:19:17.67,English,,0,0,0,,video in another couple of weeks here hopefully,
Dialogue: 0,0:19:17.67,0:19:21.10,English,,0,0,0,,showing the finishing up of the interior of the studio
Dialogue: 0,0:19:21.10,0:19:23.47,English,,0,0,0,,and it will look... hopefully quite a bit different.
Dialogue: 0,0:19:23.47,0:19:27.00,English,,0,0,0,,So anyway, stay tuned for that, and as always thanks for watching!
